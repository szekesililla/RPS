import { Component, Input, Output, EventEmitter, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Stroke {
    /**
     * @param {?=} fill
     * @param {?=} strokeFill
     * @param {?=} dashArray
     * @param {?=} thickness
     * @param {?=} opacity
     */
    constructor(fill, strokeFill, dashArray, thickness, opacity) {
        this.fill = fill != null ? fill : 'transparent';
        this.strokeFill = strokeFill != null ? strokeFill : 'black';
        this.dashArray = dashArray != null ? dashArray : 0;
        this.thickness = thickness != null ? thickness : 1;
        this.opacity = opacity != null ? opacity : 1;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Vertex {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Polygon {
    constructor() {
        this.vertices = new Array();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Polyline {
    constructor() {
        this.vertices = new Array();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgCircleComponent {
    constructor() {
        this.circleMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.circle.stroke) {
            this.circle.stroke = new Stroke();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onCircleMouseDown($event) {
        if ($event) {
            this.circleMousedown.emit({ mouseEvent: $event, circle: this.circle });
        }
    }
}
SvgCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-circle]',
                template: `<svg:circle [attr.cx]="circle?.cx"
            [attr.cy]="circle?.cy"
            [attr.r]="circle?.r"
            [attr.stroke]="circle?.stroke?.strokeFill"
            [attr.stroke-dasharray]="circle?.stroke?.dashArray"
            [attr.stroke-width]="circle?.stroke?.thickness"
            [attr.fill]="circle?.stroke?.fill"
            vector-effect="non-scaling-stroke"
            [attr.stroke-opacity]="circle?.stroke?.opacity"
            (mousedown)="onCircleMouseDown($event)"></svg:circle>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgCircleComponent.ctorParameters = () => [];
SvgCircleComponent.propDecorators = {
    "circle": [{ type: Input },],
    "circleMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgCircleModule {
}
SvgCircleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgCircleComponent],
                exports: [SvgCircleComponent]
            },] },
];
/** @nocollapse */
SvgCircleModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgLineComponent {
    constructor() {
        this.lineMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.line.stroke) {
            this.line.stroke = new Stroke();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onLineMouseDown($event) {
        if ($event) {
            this.lineMousedown.emit({ mouseEvent: $event, line: this.line });
        }
    }
}
SvgLineComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-line]',
                template: `<svg:line [attr.x1]="line?.x1"
          [attr.y1]="line?.y1"
          [attr.x2]="line?.x2"
          [attr.y2]="line?.y2"
          [attr.fill]="line?.stroke?.fill"
          [attr.stroke]="line?.stroke?.strokeFill"
          [attr.stroke-dasharray]="line?.stroke?.dashArray"
          [attr.stroke-width]="line?.stroke?.thickness"
          [attr.stroke-opacity]="line?.stroke?.opacity"
          (mousedown)="onLineMouseDown($event)" />`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgLineComponent.ctorParameters = () => [];
SvgLineComponent.propDecorators = {
    "line": [{ type: Input },],
    "lineMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgLineModule {
}
SvgLineModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgLineComponent],
                exports: [SvgLineComponent]
            },] },
];
/** @nocollapse */
SvgLineModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPolygonComponent {
    constructor() {
        this.pointsString = null;
        this.polygonMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.polygon) {
            this.pointsString = this.getPolyPoints(this.polygon.vertices);
        }
        if (!this.polygon.stroke) {
            this.polygon.stroke = new Stroke();
        }
    }
    /**
     * @param {?} points
     * @return {?}
     */
    getPolyPoints(points) {
        return points.map(p => p.x.toString() + ' ' + p.y.toString()).join(' ');
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPolygonMouseDown($event) {
        if ($event) {
            this.polygonMousedown.emit({ mouseEvent: $event, polygon: this.polygon });
        }
    }
}
SvgPolygonComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-polygon]',
                template: `<svg:polygon [attr.stroke]="polygon?.stroke?.strokeFill"
             [attr.fill]="polygon?.stroke?.fill"
             [attr.stroke-opacity]="polygon?.stroke?.opacity"
             [attr.stroke-dasharray]="polygon?.stroke?.dashArray"
             [attr.stroke-width]="polygon?.stroke?.thickness"
             [attr.points]="pointsString"
             vector-effect="non-scaling-stroke"
             (click)="onPolygonMouseDown($event)">
</svg:polygon>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgPolygonComponent.ctorParameters = () => [];
SvgPolygonComponent.propDecorators = {
    "polygon": [{ type: Input },],
    "polygonMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPolygonModule {
}
SvgPolygonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgPolygonComponent],
                exports: [SvgPolygonComponent]
            },] },
];
/** @nocollapse */
SvgPolygonModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPolylineComponent {
    constructor() {
        this.pointsString = null;
        this.polylineMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.polyline) {
            this.pointsString = this.getPolyPoints(this.polyline.vertices);
        }
        if (!this.polyline.stroke) {
            this.polyline.stroke = new Stroke();
        }
    }
    /**
     * @param {?} points
     * @return {?}
     */
    getPolyPoints(points) {
        return points.map(p => p.x.toString() + ' ' + p.y.toString()).join(' ');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPolylineMouseDown(event) {
        if (event) {
            this.polylineMousedown.emit({ mouseEvent: event, polyline: this.polyline });
        }
    }
}
SvgPolylineComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-polyline]',
                template: `<svg:polyline [attr.stroke]="polyline?.stroke?.strokeFill"
             [attr.fill]="polyline?.stroke?.fill"
             [attr.stroke-opacity]="polyline?.stroke?.opacity"
             [attr.stroke-dasharray]="polyline?.stroke?.dashArray"
             [attr.stroke-width]="polyline?.stroke?.thickness"
             [attr.points]="pointsString"
             vector-effect="non-scaling-stroke"
             (mousedown)="onPolylineMouseDown($event)">
</svg:polyline>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgPolylineComponent.ctorParameters = () => [];
SvgPolylineComponent.propDecorators = {
    "polyline": [{ type: Input },],
    "polylineMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPolylineModule {
}
SvgPolylineModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgPolylineComponent],
                exports: [SvgPolylineComponent]
            },] },
];
/** @nocollapse */
SvgPolylineModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgTextComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
SvgTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-text]',
                template: `<svg:text [attr.transform]="transform"
          [attr.x]="x"
          [attr.y]="y"
          [attr.fill]="fontStyle?.fontFill"
          [attr.font-family]="fontStyle?.fontFamily"
          [attr.font-size]="fontStyle?.fontSize"
          [attr.font-weight]="fontStyle?.fontWeight"
          [attr.font-style]="fontStyle?.fontStyle"
          dominant-baseline="central"
          text-anchor="middle">
          <ng-content></ng-content>
</svg:text>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgTextComponent.ctorParameters = () => [];
SvgTextComponent.propDecorators = {
    "x": [{ type: Input },],
    "y": [{ type: Input },],
    "transform": [{ type: Input },],
    "fontStyle": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgTextModule {
}
SvgTextModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgTextComponent],
                exports: [SvgTextComponent]
            },] },
];
/** @nocollapse */
SvgTextModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPathComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.stroke) {
            this.stroke = new Stroke();
        }
    }
}
SvgPathComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-path]',
                template: `<svg:path [attr.d]="path"
          [attr.stroke]="stroke?.strokeFill"
          [attr.stroke-dasharray]="stroke?.dashArray"
          [attr.stroke-width]="stroke?.thickness"
          [attr.fill]="stroke?.fill"
          vector-effect="non-scaling-stroke"
          [attr.stroke-opacity]="stroke?.opacity"></svg:path>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgPathComponent.ctorParameters = () => [];
SvgPathComponent.propDecorators = {
    "path": [{ type: Input },],
    "stroke": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgPathModule {
}
SvgPathModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgPathComponent],
                exports: [SvgPathComponent]
            },] },
];
/** @nocollapse */
SvgPathModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgRectComponent {
    constructor() {
        this.rectangleMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.rectangle.stroke) {
            this.rectangle.stroke = new Stroke();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRectangleMouseDown($event) {
        if ($event) {
            this.rectangleMousedown.emit({ mouseEvent: $event, rectangle: this.rectangle });
        }
    }
}
SvgRectComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-rect]',
                template: `<svg:rect [attr.x]="rectangle?.x"
          [attr.y]="rectangle?.y"
          [attr.stroke]="rectangle?.stroke?.strokeFill"
          [attr.stroke-dasharray]="rectangle?.stroke?.dashArray"
          [attr.stroke-width]="rectangle?.stroke?.thickness"
          [attr.fill]="rectangle?.stroke?.fill"
          vector-effect="non-scaling-stroke"
          [attr.stroke-opacity]="rectangle?.stroke?.opacity"
          (mousedown)="onRectangleMouseDown($event)"></svg:rectangle>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgRectComponent.ctorParameters = () => [];
SvgRectComponent.propDecorators = {
    "rectangle": [{ type: Input },],
    "rectangleMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgrectModule {
}
SvgrectModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgRectComponent],
                exports: [SvgRectComponent]
            },] },
];
/** @nocollapse */
SvgrectModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgEllipseComponent {
    constructor() {
        this.ellipseMousedown = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.ellipse.stroke) {
            this.ellipse.stroke = new Stroke();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onEllipseMouseDown($event) {
        if ($event) {
            this.ellipseMousedown.emit({ mouseEvent: $event, ellipse: this.ellipse });
        }
    }
}
SvgEllipseComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[svg-ellipse]',
                template: `<svg:ellipse [attr.cx]="ellipse?.cx"
             [attr.cy]="ellipse?.cy"
             [attr.rx]="ellipse?.rx"
             [attr.ry]="ellipse?.ry"
             [attr.stroke]="ellipse?.stroke?.strokeFill"
             [attr.stroke-dasharray]="ellipse?.stroke?.dashArray"
             [attr.stroke-width]="ellipse?.stroke?.thickness"
             [attr.fill]="ellipse?.stroke?.fill"
             vector-effect="non-scaling-stroke"
             [attr.stroke-opacity]="ellipse?.stroke?.opacity"
             (mousedown)="onEllipseMouseDown($event)"></svg:ellipse>`,
                styles: [``]
            },] },
];
/** @nocollapse */
SvgEllipseComponent.ctorParameters = () => [];
SvgEllipseComponent.propDecorators = {
    "ellipse": [{ type: Input },],
    "ellipseMousedown": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SvgEllipseModule {
}
SvgEllipseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [SvgEllipseComponent],
                exports: [SvgEllipseComponent]
            },] },
];
/** @nocollapse */
SvgEllipseModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { SvgCircleModule, SvgLineModule, SvgPolygonModule, SvgPolylineModule, SvgTextModule, SvgPathModule, SvgrectModule, SvgEllipseModule, Stroke, Vertex, Polygon, Polyline, SvgCircleComponent as ɵa, SvgEllipseComponent as ɵh, SvgLineComponent as ɵb, SvgPathComponent as ɵf, SvgPolygonComponent as ɵc, SvgPolylineComponent as ɵd, SvgRectComponent as ɵg, SvgTextComponent as ɵe };
//# sourceMappingURL=angular-svg.js.map
